\chapter{Introduction}
\section{Electronic voting}
Since 2015, it is possible for Swiss citizens registered in the cantons Geneva and Neuch√¢tel and living abroad, to vote electronically. However, these systems did not yet meet the requirements in terms of security and transparency, to be accepted as a secure E-Voting platform on a nationwide scale.

One of the requirements that is hardest to achieve, is that the system must ensure the voters privacy while at the same time, it must be verifiable that only valid votes have been counted. A good e-voting system must be transparent and allow an external person to verify, that every protocol participant has abided by the protocol and that all votes have been counted correctly.

Another common problem is the insecure platform problem: If a voters computer is affected by malware, the vote casting process is no longer under the voters control and the candidate selection could be possibly manipulated without the voters notice. 

A contract was formed between the state of Geneva and the Bern University of Applied Sciences to work out a new protocol which does meet the complex requirements set up by the government. In 2017, the resulting specification document has been officially published and a proof-of-concept / prototype has been successfully implemented by the State of Geneva. 

\section{The CHVote protocol}
The protocol our project is based on, does not originate from us! The concept and specification has been created by Rolf Haenni, Philipp Locher and Reto E. Koenig of the Institute for Security in the Information Society (RISIS) of the Bern University of Applied Sciences. For this project, we have implemented the protocol according to their specification. In this section we summarize the most important aspects of the protocol and establish the terminology for better understanding this document and our application.

\subsection{Actors}
A \textbf{voter} is a person who is eligible to vote in his respective state. Every voter must possess a voting card that has been sent to him prior to an election and that contains several codes such as the voting code and the confirmation code, which are used to identify the voter during the vote casting process.

A voter uses a \textbf{voting client} to participate in the protocol, e.g. forming a ballot according to the protocol, by entering his selection, a voting code to cast, and later in the process, his confirmation code to confirm his vote. Verification codes and a finalization code are displayed by the voting client to ensure the voter that his vote has been cast as intended and hasn't been manipulated by a third party.

The \textbf{Election Administrator}, typically a person of the government, sets up the election by providing the necessary information such as the candidates and the voters and initiates the generation of the cryptographic electorate data. He is also responsible for tallying the election and publishing the final results.

The \textbf{election authorities} can be seen as some kind of independent election observers. In a CHVote election there are always multiple election authorities in order to avoid having a single authority that has to be trusted. The authorities are involved in almost every step of the protocol, starting from generating their shares of the electorate data, shares of a joint public key used for encryption, checking and responding to new ballots and vote confirmations, as well as in the mixing and decryption phases.

The \textbf{Bulletin Board} acts as a central board over which most communication is done and where all the public data is stored.

The \textbf{Printing Authority} is responsible for printing the voting cards for all voters. Since the printing authority needs to be in possession of all the secret voting credentials, it is a very sensitive point in the protocol. The printed voting cards are handled over to a trusted mailing service for delivery.

\subsection{Pre-Election \& Voting cards}
Before the actual election phase, the vote administrator sets up the election by entering all required parameters, namely the voters, the elections with their corresponding candidates and the number of all. All election authorities jointly generate the cryptographic data for the whole electorate from which the voting card information is derived. The printing authority combines the information from all election authorities, prints the voting cards and deliver them to the voters by a trusted mailing service. 

A voting card contains several codes, namely:

\begin{itemize}
	\item a voting code
	\item a confirmation code
	\item a finalization code
	\item one verification code for every candidate
\end{itemize}

The voting and confirmation codes are authentication codes and used to authenticate the voter twice during the vote casting process; the first time with the voting code when he casts his vote, and a second time for confirming his vote. A second authentication code is required because otherwise an attacker who infected a voters computer with malware could just confirm a vote on behalf of the voter after he manipulated the candidate selection. 

\subsection{Cast-as-intended verification with oblivious transfer}

Even with the authentication codes, an insecure voting platform infected with malware still poses the risk that an attacker manipulates the candidate selection on the vote-casting page after the voter has entered his voting code. 

The CHVote specification suggests a "`Cast-as-intended verification"' to allow voters to detect this kind of manipulation:

When a voter enters his voting code and the indices of his favored candidates, the voting client forms a \textbf{ballot} containing the voters selection encrypted with the authorities public key, his public voting credential derived from the voting code, and a zero knowledge proof which proofs that the voter has formed the ballot according to the protocol and that he has been in knowledge of his voting code.

Every election authority now checks the voters public voting credential, the validity of the ballot proof and that the voter hasn't already cast a vote. 

The encrypted selection also serves as a query for an oblivious transfer. A k-out-of-n oblivious transfer allows a client to query a server for k messages, without the server knowing what k messages the client requested, and without the client learning anything about the n-k other messages. Adapted to the CHVote protocol, the query queries the authorities for the corresponding verification codes of the selected candidates, without the authorities learning which candidates the voter has selected, and without revealing any information about the other candidates. 

The voter then checks if the returned verification codes match the codes of the candidates he has chosen on the printed voting card. If the selection was somehow manipulated by malware, the returned verification codes would not match the printed ones and the voter would have to abort the vote casting process. This way the integrity of the vote casting can be assured even in the presence of malware. In such a case, privacy on the other hand cannot be protected since the malware will learn the plaintext of the voter's selection.

In order to verify that a voter has formed the ballot correctly by choosing exactly the number of candidates he is supposed to choose, the following trick is being used: the verification codes are derived from $n = \sum_{n=1}^{t} n_j$ random points on $t$ polynomials (one for every election event $j$) of degree $k_j - 1$, that each election authority has chosen randomly prior to the election. By learning exactly $k = \sum_{n=1}^{t} k_j$ points on these polynomials, the voting client is able to reproduce these polynomials and therefore is able to calculate a particular point with $x=0$ on these polynomials. The corresponding $y$ values are incorporated into the second voting credential from which the confirmation code is derived. Only if the voter knows these points (by submitting a valid candidate selection), he will be able to confirm the vote that he casted.

\subsection{Re-encryption mix network}

Since there is still a connection between the encrypted ballot and the voter at this point, the encrypted selections are extracted from the ballots as the first step of the post-election phase. In order to anonymize the list of encryptions, every authority performs a cryptographic shuffle with a random permutation and re-encrypts all ciphertexts in order to make it impossible to find out which voter has submitted which encrypted ballot. This is done by using the multiplicative homomorphic property of the ElGamal encryption scheme. A multiplicative homomorphic encryption scheme allows to perform multiplications on the ciphertext such that:

\begin{equation*}Enc(a) \cdot Enc(b) = Enc(a \cdot b)\end{equation*}

The specification suggests multiplying the encryption with the encryption of the neutral element $1$ since this yields a new ciphertext for the exact same plaintext.

\subsection{Distributed trust}
The public key that is used for encrypting the ballots has been jointly generated by all election authorities. Therefore in order to decrypt the result, all authorities must provide their share of the private key. The measure of multiple authorities participating in the whole e-voting process ensures the security of the whole election even if only one authority can be trusted.

\section{Project task}

Understanding such a complex protocol isn't easy and might be the reason why many people still do not trust electronic e-voting systems. In close consultation with the authors of the CHVote specification, we agreed to develop an application that allows users to get a hands-on experience with the CHVote e-voting system and makes it possible to show to an audience how the future of voting in Switzerland might possibly look like.

For this reason, we have implemented the protocol according to the specification and developed a web-based application on top of it, which allows to perform every step of an election, from generating the electorate data, to casting and confirming ballots from a voters point of view, to the post-election processes like mixing, decryption and tallying.
