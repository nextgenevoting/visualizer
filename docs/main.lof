\select@language {english}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {1.1}{\ignorespaces The initial task description of the bachelor thesis left a number of open possibilities as to how exactly the project could be implemented. Specific tasks and requirements were discussed with our supervisors during the first few weeks of the project.\relax }}{9}{figure.1.1}
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces During the mixing phase, the encryptions are extracted from the list of ballots and then shuffled with a random permutation and re-encrypted by all election authorities. This measure ensures the anonymity of the votes.\relax }}{20}{figure.3.1}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces An election event consists of 7 different phases (green). During the election phase a voter can be in 3 different phases (blue)\relax }}{22}{figure.caption.5}
\contentsline {figure}{\numberline {4.2}{\ignorespaces The election overview guides the user through the several phases of an election event and indicates which phases have been finished and what the next steps are.\relax }}{22}{figure.caption.6}
\contentsline {figure}{\numberline {4.3}{\ignorespaces The election authority view as an example of how the pages are generally structured: most views are divided into a tasks part which allows to perform the tasks of an actor, and a data part which shows what information about an election event the participant is in possession of. \relax }}{24}{figure.caption.7}
\contentsline {figure}{\numberline {4.4}{\ignorespaces The tab beyond the page header is the main control for navigating through the different pages. It also indicates where some interaction is required next by displaying an exclamation mark icon in the respective actor's tab.\relax }}{24}{figure.caption.8}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {5.1}{\ignorespaces From a high level perspective, our application consists of 3 main components: the front-end (web-application), the back-end, and the crypto-library.\relax }}{27}{figure.caption.9}
\contentsline {figure}{\numberline {5.2}{\ignorespaces The architecture with the front- and the back-end. Both sides contain a database / data-store that stores the current state of an election event. Whenever some action is called on the server side by calling test REST API, the changes are written to the database and synchronized to all clients over web-sockets. The resulting manipulations on the local data-store are automatically updated in the user's view by binding the user controls to the local data-store.\relax }}{30}{figure.caption.10}
\contentsline {figure}{\numberline {5.3}{\ignorespaces The internals of the VoteService: the functionality is divided into actor- and state-classes. The actors provide the functionality as described in the specification and by utilizing the crypto-library. The state is contained within the state classes that allow easy serialization both for persisting them to the database as well as to a JSON representation for the data synchronization. \relax }}{32}{figure.caption.11}
\contentsline {figure}{\numberline {5.4}{\ignorespaces The state of an election event is broken down into separate state classes for every participating actor. The thing they have in common is that they are serializable to JSON\relax }}{33}{figure.caption.12}
\contentsline {figure}{\numberline {5.5}{\ignorespaces Example of a MongoDB collection (the equivalence of tables in other database systems). All states are stored as binary strings together with an identifier for the election-event as well as the election authority ID.\relax }}{34}{figure.caption.13}
\contentsline {figure}{\numberline {5.6}{\ignorespaces The functionality of the VoteService is divided into separate classes, one for each participating actor of the protocol.\relax }}{35}{figure.caption.14}
\contentsline {figure}{\numberline {5.7}{\ignorespaces For every VoteService state there is a corresponding data-store on the client side. The client side data-store are initially populated with the whole dataset during the initial loading procedure of an election event.\relax }}{36}{figure.caption.15}
\contentsline {figure}{\numberline {5.8}{\ignorespaces JSON Patch is an RFC standard that describes a procedure to incrementally patch a JSON object. By comparing two JSON objects, JSON Patch creates a set of operations that are needed to patch one object to match the other. We used JSON Patch to keep the client side data-stores in sync with the central database. The picture shows the resulting operations after submitting a new ballot.\relax }}{37}{figure.caption.16}
\contentsline {figure}{\numberline {5.9}{\ignorespaces After the client side data-stores have been initially loaded, future mutations of the central database are synchronized to all clients by receiving and applying JSON Patches, which contain operations to patch the local data-stores to be in sync with the back-end.\relax }}{38}{figure.caption.17}
\contentsline {figure}{\numberline {5.10}{\ignorespaces Vote casting sequence diagram, showing how all components of the application are working together during vote casting\relax }}{40}{figure.5.10}
\contentsline {figure}{\numberline {5.11}{\ignorespaces Our data-card component that allows content to be injected in different places within its DOM by using the slot-concept of VueJS.\relax }}{45}{figure.caption.18}
\addvspace {10\p@ }
\addvspace {10\p@ }
